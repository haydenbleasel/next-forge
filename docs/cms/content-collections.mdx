---
title: Switch to Content Collections
description: How to switch to Content Collections.
---

It's possible to switch to [Content Collections](https://www.content-collections.dev/) to generate type-safe data collections from MDX files. This approach provides a structured way to manage blog posts while maintaining full type safety throughout your application.

## 1. Swap out the required dependencies

Remove the existing dependencies...

```sh Terminal
pnpm remove basehub --filter cms
pnpm remove concurrently --filter web
```

... and install the new dependencies...

```sh Terminal
pnpm add @content-collections/mdx next --filter cms
pnpm add -D @content-collections/cli @content-collections/core @content-collections/next --filter cms
```

## 2. Update the `web` scripts

Update the `package.json` file to remove the `prebuild` and `concurrently` scripts:

```json apps/web/package.json {2}
"scripts": {
  "dev": "next dev -p 3001 --turbopack"
}
```

## 3. Update the `.gitignore` file

Remove `.basehub` from the `.gitignore` file...

```git apps/web/.gitignore {1-2}
# basehub
.basehub
```

... and add `.content-collections` to the `.gitignore` file:

```git apps/web/.gitignore {1-2}
# content-collections
.content-collections
```

## 4. Modify the relevant CMS package files

<CodeGroup>

```ts packages/cms/next-config.ts {1}
export { withContentCollections as withCMS } from '@content-collections/next';
```

```ts packages/cms/index.ts
import { allPosts } from 'content-collections';

export const blog = {
  postsQuery: {
    blog: {
      posts: {
        items: postFragment,
      },
    },
  } as const,

  latestPostQuery: {
    blog: {
      posts: {
        __args: {
          orderBy: '_sys_createdAt__DESC',
          first: 1,
        },
        items: postFragment,
      },
    },
  } as const,

  postQuery: (slug: string) => ({
    blog: {
      posts: {
        __args: {
          filter: {
            _sys_slug: { eq: slug },
          },
        },
        items: postFragment,
      },
    },
  }),

  getPosts: async () => allPosts,

  getLatestPost: async () =>
    allPosts.sort((a, b) => a.date.getTime() - b.date.getTime()).at(0),

  getPost: async (slug: string) => 
    allPosts.find(({ _meta }) => _meta.path === slug),
};

export const legal = {
  postsQuery: {
    legalPages: {
      items: legalPostFragment,
    },
  } as const,

  latestPostQuery: {
    legalPages: {
      __args: {
        orderBy: '_sys_createdAt__DESC',
        first: 1,
      },
      items: legalPostFragment,
    },
  } as const,

  postQuery: (slug: string) => ({
    legalPages: {
      __args: {
        filter: {
          _sys_slug: { eq: slug },
        },
      },
      items: legalPostFragment,
    },
  }),

  getPosts: async () => {
    const data = await basehub().query(legal.postsQuery);

    return data.legalPages.items;
  },

  getLatestPost: async () => {
    const data = await basehub().query(legal.latestPostQuery);

    return data.legalPages.items.at(0);
  },

  getPost: async (slug: string) => {
    const query = legal.postQuery(slug);
    const data = await basehub().query(query);

    return data.legalPages.items.at(0);
  },
};
```

```tsx packages/cms/components/body.tsx
import { MDXContent } from '@content-collections/mdx/react';
import Image from 'next/image';
import Link from 'next/link';
import type { ComponentProps, HTMLProps } from 'react';

const a = ({ href, ...properties }: HTMLProps<HTMLAnchorElement>) => {
  if (typeof href !== 'string') {
    throw new TypeError('href is required');
  }

  if (href.startsWith('/')) {
    return <Link href={href} {...properties} />;
  }

  return (
    <a {...properties} href={href} target="_blank" rel="noopener noreferrer" />
  );
};

const img = (properties: HTMLProps<HTMLImageElement>) => {
  if (
    typeof properties.src !== 'string' ||
    typeof properties.alt !== 'string'
  ) {
    throw new TypeError('Image src and alt are required');
  }

  return (
    <Image
      src={properties.src}
      alt={properties.alt}
      width={1240}
      height={698}
      unoptimized={properties.src.startsWith('http')}
      className="overflow-hidden rounded"
    />
  );
};

const CompanyName = () => 'next-forge';

export const Mdx = ({
  code,
  components,
}: ComponentProps<typeof MDXContent>) => (
  <div className="prose prose-neutral dark:prose-invert">
    <MDXContent
      code={code}
      components={{
        a,
        img,
        CompanyName,
        ...components,
      }}
    />
  </div>
);
```

</CodeGroup>

## 5. Modify the relevant `web` package files

```json apps/web/tsconfig.json {4}
{
  "compilerOptions": {
    "paths": {
      "content-collections": ["./.content-collections/generated"]
    }
  }
}
```

## 6. Create your content collections

Create a new content collections file in the `cms` package, then import the collections in the `web` package.

<Note>We're remapping the `title` field to `_title` and the `_meta.path` field to `_slug` to match the default next-forge CMS.</Note>

<CodeGroup>

```ts packages/cms/collections.ts
import { defineCollection, defineConfig } from '@content-collections/core';
import { compileMDX } from '@content-collections/mdx';

const posts = defineCollection({
  name: 'posts',
  directory: 'content/blog',
  include: '**/*.mdx',
  schema: (z) => ({
    title: z.string(),
    description: z.string(),
    date: z.string(),
    image: z.string(),
    authors: z.array(z.string()),
    tags: z.array(z.string()),
  }),
  transform: async ({ title, ...page }, context) => {
    const body = await context.cache(page.content, async () =>
      compileMDX(context, page)
    );

    return {
      ...page,
      _title: title,
      _slug: page._meta.path,
      body,
    };
  },
});

const legals = defineCollection({
  name: 'legal',
  directory: 'content/legal',
  include: '**/*.mdx',
  schema: (z) => ({
    title: z.string(),
    description: z.string(),
    date: z.string(),
  }),
  transform: async ({ title, ...page }, context) => {
    const body = await context.cache(page.content, async () =>
      compileMDX(context, page)
    );

    return {
      ...page,
      _title: title,
      _slug: page._meta.path,
      body,
    };
  },
});

export default defineConfig({
  collections: [posts, legals],
});
```

```ts packages/web/content-collections.ts
export { default } from '@repo/cms/collections';
```

</CodeGroup>

## 7. Update the blog and legal pages

<CodeGroup>

```tsx apps/web/app/blog/page.tsx
import { cn } from '@repo/design-system/lib/utils';
import type { Blog, WithContext } from '@repo/seo/json-ld';
import { JsonLd } from '@repo/seo/json-ld';
import { createMetadata } from '@repo/seo/metadata';
import { allPosts } from 'content-collections';
import type { Metadata } from 'next';
import Image from 'next/image';
import Link from 'next/link';

const title = 'Blog';
const description = 'Thoughts, ideas, and opinions.';

export const metadata: Metadata = createMetadata({ title, description });

const BlogIndex = () => {
  const jsonLd: WithContext<Blog> = {
    '@type': 'Blog',
    '@context': 'https://schema.org',
  };

  return (
    <>
      <JsonLd code={jsonLd} />
      <div className="w-full py-20 lg:py-40">
        <div className="container mx-auto flex flex-col gap-14">
          <div className="flex w-full flex-col gap-8 sm:flex-row sm:items-center sm:justify-between">
            <h4 className="max-w-xl font-regular text-3xl tracking-tighter md:text-5xl">
              Latest articles
            </h4>
          </div>
          <div className="grid grid-cols-1 gap-8 md:grid-cols-2">
            {allPosts.map((post, index) => (
              <Link
                href={`/blog/${post._meta.path}`}
                className={cn(
                  'flex cursor-pointer flex-col gap-4 hover:opacity-75',
                  !index && 'md:col-span-2'
                )}
                key={post.title}
              >
                <Image
                  src={post.image}
                  alt={post.title}
                  width={1336}
                  height={751}
                  blurDataURL={post.imageBlur}
                  placeholder="blur"
                />
                <div className="flex flex-row items-center gap-4">
                  <p className="text-muted-foreground text-sm">
                    {new Date(post.date).toLocaleDateString('en-US', {
                      month: 'long',
                      day: 'numeric',
                      year: 'numeric',
                    })}
                  </p>
                </div>
                <div className="flex flex-col gap-2">
                  <h3 className="max-w-3xl text-4xl tracking-tight">
                    {post.title}
                  </h3>
                  <p className="max-w-3xl text-base text-muted-foreground">
                    {post.description}
                  </p>
                </div>
              </Link>
            ))}
          </div>
        </div>
      </div>
    </>
  );
};

export default BlogIndex;
```

```tsx apps/web/app/blog/[slug]/page.tsx {1}
import { Mdx } from '@/components/mdx';
import { Sidebar } from '@/components/sidebar';
import { ArrowLeftIcon } from '@radix-ui/react-icons';
import { env } from '@repo/env';
import { type BlogPosting, JsonLd, type WithContext } from '@repo/seo/json-ld';
import { createMetadata } from '@repo/seo/metadata';
import { allPosts } from 'content-collections';
import type { Metadata } from 'next';
import Image from 'next/image';
import Link from 'next/link';
import { notFound } from 'next/navigation';
import Balancer from 'react-wrap-balancer';

type BlogPostProperties = {
  readonly params: Promise<{
    slug: string;
  }>;
};

export const generateMetadata = async ({
  params,
}: BlogPostProperties): Promise<Metadata> => {
  const { slug } = await params;
  const page = allPosts.find(({ _meta }) => _meta.path === slug);

  if (!page) {
    return {};
  }

  return createMetadata({
    title: page.title,
    description: page.description,
    image: page.image,
  });
};

export const generateStaticParams = (): { slug: string }[] =>
  allPosts.map((page) => ({
    slug: page._meta.path,
  }));

const BlogPost = async ({ params }: BlogPostProperties) => {
  const { slug } = await params;
  const page = allPosts.find(({ _meta }) => _meta.path === slug);

  if (!page) {
    notFound();
  }

  const jsonLd: WithContext<BlogPosting> = {
    '@type': 'BlogPosting',
    '@context': 'https://schema.org',
    datePublished: page.date.toISOString(),
    description: page.description,
    mainEntityOfPage: {
      '@type': 'WebPage',
      '@id': new URL(
        `/blog/${slug}`,
        env.NEXT_PUBLIC_VERCEL_PROJECT_PRODUCTION_URL
      ).toString(),
    },
    headline: page.title,
    image: page.image,
    dateModified: page.date.toISOString(),
    author: page.authors.at(0),
    isAccessibleForFree: true,
  };

  return (
    <>
      <JsonLd code={jsonLd} />
      <div className="container py-16">
        <Link
          className="mb-4 inline-flex items-center gap-1 text-muted-foreground text-sm focus:underline focus:outline-none"
          href="/blog"
        >
          <ArrowLeftIcon className="h-4 w-4" />
          Back to Blog
        </Link>
        <h1 className="scroll-m-20 font-extrabold text-4xl tracking-tight lg:text-5xl">
          <Balancer>{page.title}</Balancer>
        </h1>
        <p className="leading-7 [&:not(:first-child)]:mt-6">
          <Balancer>{page.description}</Balancer>
        </p>
        {page.image ? (
          <Image
            src={page.image}
            width={1920}
            height={1080}
            alt=""
            className="my-16 h-full w-full rounded-xl"
            priority
            blurDataURL={page.imageBlur}
            placeholder="blur"
          />
        ) : undefined}
        <div className="mt-16 flex flex-col items-start gap-8 sm:flex-row">
          <div className="sm:flex-1">
            <Mdx code={page.body} />
          </div>
          <div className="sticky top-24 hidden shrink-0 md:block">
            <Sidebar
              content={page.content}
              readingTime={page.readingTime}
              date={page.date}
            />
          </div>
        </div>
      </div>
    </>
  );
};

export default BlogPost;
```

</CodeGroup>

## 8. Bonus features

### Fumadocs MDX Plugins

You can use the [Fumadocs](/documentation/fumadocs) MDX plugins to enhance your MDX content.

```ts {1-6,8-13,20-23}
import {
  type RehypeCodeOptions,
  rehypeCode,
  remarkGfm,
  remarkHeading,
} from 'fumadocs-core/mdx-plugins';

const rehypeCodeOptions: RehypeCodeOptions = {
  themes: {
    light: 'catppuccin-mocha',
    dark: 'catppuccin-mocha',
  },
};

const posts = defineCollection({
  // ...
  transform: async (page, context) => {
    // ...
    const body = await context.cache(page.content, async () =>
      compileMDX(context, page, {
        remarkPlugins: [remarkGfm, remarkHeading],
        rehypePlugins: [[rehypeCode, rehypeCodeOptions]],
      })
    );

    // ...
  },
});
```

### Reading Time

You can calculate reading time for your collection by adding a transform function.

```ts {1,10}
import readingTime from 'reading-time';

const posts = defineCollection({
  // ...
  transform: async (page, context) => {
    // ...

    return {
      // ...
      readingTime: readingTime(page.content).text,
    };
  },
});
```

### Low-Quality Image Placeholder (LQIP)

You can generate a low-quality image placeholder for your collection by adding a transform function.

```ts {1,8-19,23,24}
import { sqip } from 'sqip';

const posts = defineCollection({
  // ...
  transform: async (page, context) => {
    // ...

    const blur = await context.cache(page._meta.path, async () =>
      sqip({
        input: `./public/${page.image}`,
        plugins: [
          'sqip-plugin-primitive',
          'sqip-plugin-svgo',
          'sqip-plugin-data-uri',
        ],
      })
    );

    const result = Array.isArray(blur) ? blur[0] : blur;

    return {
      // ...
      image: page.image,
      imageBlur: result.metadata.dataURIBase64 as string,
    };
  },
});
```

-----

## Creating blog posts

To create a new blog post, add a new MDX file to the `apps/web/content/blog` directory. The file name will be used as the slug for the blog post and the frontmatter will be used to generate the blog post page. For example:

```mdx apps/web/content/blog/my-first-post.mdx
---
title: 'My First Post'
description: 'This is my first blog post'
date: 2024-10-23
image: /blog/my-first-post.png
---
```

The same concept applies to the `legal` collection, which is used to generate the legal policy pages. Also, the `image` field is the path relative to the app's root `public` directory.

## Creating a collection

To create a new collection, you'll need to define it in the `content-collections.ts` file in the web directory. For example, here's how you can define a simple new collection called `docs`:

```ts apps/web/content-collections.ts {3-7, 10}
import { defineCollection } from '@content-collections/core';

const docs = defineCollection({
  name: 'docs',
  directory: 'content/docs',
  include: '**/*.mdx',
});

export default defineConfig({
  collections: [posts, legals, docs],
});
```
